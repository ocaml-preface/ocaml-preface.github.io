<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Selective (preface.Preface_specs__.Selective)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">preface</a> &#x00BB; <a href="../index.html">Preface_specs__</a> &#x00BB; Selective</nav><h1>Module <code>Preface_specs__.Selective</code></h1><nav class="toc"><ul><li><a href="#laws">Laws</a><ul><li><a href="#laws-for-rigid-selectives">Laws for Rigid Selectives</a></li></ul></li><li><a href="#minimal-definition">Minimal definition</a></li><li><a href="#structure-anatomy">Structure anatomy</a></li><li><a href="#complete-api">Complete API</a></li><li><a href="#additional-references">Additional references</a></li></ul></nav></header><aside><p>A <code>Selective</code> (applicative functor) allows to declare effects statically and select which execute dynamically. It is an algebraic structure between <a href="../Applicative/index.html"><code>Applicative</code></a> and <a href="../Monad/index.html"><code>Monad</code></a>. A <code>Selective</code> is also an <a href="../Applicative/index.html"><code>Applicative</code></a>.</p></aside><section><header><h3 id="laws"><a href="#laws" class="anchor"></a>Laws</h3><p>To have a predictable behaviour, the instance of <code>Selective</code> must obey some laws.</p><ol><li><code>x &lt;*? pure id = Either.case id id &lt;$&gt; x</code></li><li><code>pure x &lt;*? (y *&gt; z) = (pure x &lt;*? y) *&gt; (pure x &lt;*? z)</code></li><li><code>x &lt;*? (y &lt;*? z) = (f &lt;$&gt; x) &lt;*? (g &lt;$&gt; y) &lt;*? (h &lt;$&gt; z)</code></li><li><code>f &lt;$&gt; select x y) = (select (Bifunctor.map_snd f &lt;$&gt; x) (((%) f) &lt;$&gt; y)</code></li><li><code>(select (Bifunctor.map_fst f &lt;$&gt; x) y) = (select x ((%&gt;) f) &lt;$&gt; y))</code></li><li><code>(select x (f &lt;$&gt; y)) = (select (Bifunctor.map_fst (flip f) &lt;$&gt; x) ((|&gt;) \
     &lt;$&gt; y))</code></li><li><code>(x &lt;*? pure y) = (Either.case y id &lt;$&gt; x)</code></li><li><code>(pure (Right x) &lt;*? y) = pure x</code></li><li><code>(pure (Left x) &lt;*? y) = ((|&gt;) x) &lt;$&gt; y</code></li></ol></header><section><header><h4 id="laws-for-rigid-selectives"><a href="#laws-for-rigid-selectives" class="anchor"></a>Laws for Rigid Selectives</h4><p>A <code>selective</code> is <code>Rigid</code> if <code>apply</code> can be defined in term of <code>select</code></p><ol><li><code>f &lt;*&gt; g = apply f g</code></li><li><code>(x *&gt; (y &lt;*? z)) = ((x *&gt; y) &lt;*? z)</code></li></ol></header></section></section><section><header><h2 id="minimal-definition"><a href="#minimal-definition" class="anchor"></a>Minimal definition</h2></header><dl><dt class="spec module-type" id="module-type-WITH_SELECT"><a href="#module-type-WITH_SELECT" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WITH_SELECT/index.html">WITH_SELECT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Minimal definition using <code>select</code> without <a href="../Applicative/index.html"><code>Applicative</code></a> requirements.</p></dd></dl><dl><dt class="spec module-type" id="module-type-WITH_BRANCH"><a href="#module-type-WITH_BRANCH" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WITH_BRANCH/index.html">WITH_BRANCH</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Minimal definition using <code>branch</code> without <a href="../Applicative/index.html"><code>Applicative</code></a> requirements.</p></dd></dl><dl><dt class="spec module-type" id="module-type-WITH_PURE_AND_SELECT"><a href="#module-type-WITH_PURE_AND_SELECT" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WITH_PURE_AND_SELECT/index.html">WITH_PURE_AND_SELECT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Standard requirement including <code>pure</code> and <code>select</code>.</p></dd></dl><dl><dt class="spec module-type" id="module-type-WITH_PURE_AND_BRANCH"><a href="#module-type-WITH_PURE_AND_BRANCH" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WITH_PURE_AND_BRANCH/index.html">WITH_PURE_AND_BRANCH</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Standard requirement including <code>pure</code> and <code>branch</code>.</p></dd></dl></section><section><header><h2 id="structure-anatomy"><a href="#structure-anatomy" class="anchor"></a>Structure anatomy</h2></header><dl><dt class="spec module-type" id="module-type-CORE"><a href="#module-type-CORE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-CORE/index.html">CORE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Basis operation.</p></dd></dl><dl><dt class="spec module-type" id="module-type-OPERATION"><a href="#module-type-OPERATION" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-OPERATION/index.html">OPERATION</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Additional operations.</p></dd></dl><dl><dt class="spec module-type" id="module-type-SYNTAX"><a href="#module-type-SYNTAX" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SYNTAX/index.html">SYNTAX</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Syntax extensions.</p></dd></dl><dl><dt class="spec module-type" id="module-type-INFIX"><a href="#module-type-INFIX" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-INFIX/index.html">INFIX</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Infix operators.</p></dd></dl></section><section><header><h2 id="complete-api"><a href="#complete-api" class="anchor"></a>Complete API</h2></header><dl><dt class="spec module-type" id="module-type-API"><a href="#module-type-API" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-API/index.html">API</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The complete interface of a <code>Selective</code>.</p></dd></dl></section><section><header><h2 id="additional-references"><a href="#additional-references" class="anchor"></a>Additional references</h2><ul><li><a href="http://hackage.haskell.org/package/selective">Haskell's documentation of a Selective Application Functor</a></li><li><a href="https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf">Selective Applicative Functors</a></li></ul></header></section></div></body></html>